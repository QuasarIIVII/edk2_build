     1                                  ;------------------------------------------------------------------------------
     2                                  ; @file
     3                                  ; This file includes all other code files to assemble the reset vector code
     4                                  ;
     5                                  ; Copyright (c) 2008 - 2013, Intel Corporation. All rights reserved.<BR>
     6                                  ; Copyright (c) 2020 - 2024, Advanced Micro Devices, Inc. All rights reserved.<BR>
     7                                  ; SPDX-License-Identifier: BSD-2-Clause-Patent
     8                                  ;
     9                                  ;------------------------------------------------------------------------------
    10                                  
    11                                  ;
    12                                  ; If neither ARCH_IA32 nor ARCH_X64 are defined, then try to include
    13                                  ; Base.h to use the C pre-processor to determine the architecture.
    14                                  ;
    15                                  %ifndef ARCH_IA32
    16                                    %ifndef ARCH_X64
    17                                  
    18                                  
    19                                        %define ARCH_IA32
    20                                  
    21                                  
    22                                  
    23                                    %endif
    24                                  %endif
    25                                  
    26                                  %ifdef ARCH_IA32
    27                                    %ifdef ARCH_X64
    28                                      %error "Only one of ARCH_IA32 or ARCH_X64 can be defined."
    29                                    %endif
    30                                  %elifdef ARCH_X64
    31                                  %else
    32                                    %error "Either ARCH_IA32 or ARCH_X64 must be defined."
    33                                  %endif
    34                                  
    35                                  %include "CommonMacros.inc"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Common macros used in the ResetVector VTF module.
     4                              <1> ;
     5                              <1> ; Copyright (c) 2008, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> %define ADDR16_OF(x) (0x10000 - fourGigabytes + x)
    11                              <1> %define ADDR_OF(x) (0x100000000 - fourGigabytes + x)
    12                              <1> 
    13                              <1> %macro  OneTimeCall 1
    14                              <1>     jmp     %1
    15                              <1> %1 %+ OneTimerCallReturn:
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro  OneTimeCallRet 1
    19                              <1>     jmp     %1 %+ OneTimerCallReturn
    20                              <1> %endmacro
    21                              <1> 
    22                              <1> StartOfResetVectorCode:
    23                              <1> 
    24                              <1> %define ADDR_OF_START_OF_RESET_CODE ADDR_OF(StartOfResetVectorCode)
    25                              <1> 
    36                                  
    37                                  %include "PostCodes.inc"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Definitions of POST CODES for the reset vector module
     4                              <1> ;
     5                              <1> ; Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> %define POSTCODE_16BIT_MODE     0x16
    11                              <1> %define POSTCODE_32BIT_MODE     0x32
    12                              <1> %define POSTCODE_64BIT_MODE     0x64
    13                              <1> 
    14                              <1> %define POSTCODE_BFV_NOT_FOUND  0xb0
    15                              <1> %define POSTCODE_BFV_FOUND      0xb1
    16                              <1> 
    17                              <1> %define POSTCODE_SEC_NOT_FOUND  0xf0
    18                              <1> %define POSTCODE_SEC_FOUND      0xf1
    19                              <1> 
    38                                  
    39                                  %ifdef DEBUG_PORT80
    40                                    %include "Port80Debug.asm"
    41                                  %elifdef DEBUG_SERIAL
    42                                    %include "SerialDebug.asm"
    43                                  %elif 0
    44                                  ; Set ^ this to 1 to enable postcodes on the qemu debug console.
    45                                  ; Disabled by default because it is incompatible with SEV-ES/SEV-SNP and TDX.
    46                                    %include "QemuDebugCon.asm"
    47                                  %else
    48                                    %include "DebugDisabled.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Debug disabled
     4                              <1> ;
     5                              <1> ; Copyright (c) 2009, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> BITS    16
    11                              <1> 
    12                              <1> %macro  debugInitialize 0
    13                              <1>     ;
    14                              <1>     ; No initialization is required
    15                              <1>     ;
    16                              <1> %endmacro
    17                              <1> 
    18                              <1> %macro  debugShowPostCode 1
    19                              <1> %endmacro
    20                              <1> 
    49                                  %endif
    50                                  
    51                                  %include "Ia32/SearchForBfvBase.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Search for the Boot Firmware Volume (BFV) base address
     4                              <1> ;
     5                              <1> ; Copyright (c) 2008 - 2022, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> ;#define EFI_FIRMWARE_FILE_SYSTEM2_GUID ;  { 0x8c8ce578, 0x8a3d, 0x4f1c, { 0x99, 0x35, 0x89, 0x61, 0x85, 0xc3, 0x2d, 0xd3 } }
    12                              <1> %define FFS2_GUID_DWORD0 0x8c8ce578
    13                              <1> %define FFS2_GUID_DWORD1 0x4f1c8a3d
    14                              <1> %define FFS2_GUID_DWORD2 0x61893599
    15                              <1> %define FFS2_GUID_DWORD3 0xd32dc385
    16                              <1> 
    17                              <1> ;#define EFI_FIRMWARE_FILE_SYSTEM3_GUID ;  { 0x8c8ce578, 0x3dcb, 0x4dca, { 0xbd, 0x6f, 0x1e, 0x96, 0x89, 0xe7, 0x34, 0x9a } }
    19                              <1> %define FFS3_GUID_DWORD0 0x5473c07a
    20                              <1> %define FFS3_GUID_DWORD1 0x4dca3dcb
    21                              <1> %define FFS3_GUID_DWORD2 0x961e6fbd
    22                              <1> %define FFS3_GUID_DWORD3 0x9a34e789
    23                              <1> 
    24                              <1> BITS    32
    25                              <1> 
    26                              <1> ;
    27                              <1> ; Modified:  EAX, EBX
    28                              <1> ; Preserved: EDI, ESP
    29                              <1> ;
    30                              <1> ; @param[out]  EBP  Address of Boot Firmware Volume (BFV)
    31                              <1> ;
    32                              <1> Flat32SearchForBfvBase:
    33                              <1> 
    34 00000000 31C0                <1>     xor     eax, eax
    35                              <1> searchingForBfvHeaderLoop:
    36                              <1>     ;
    37                              <1>     ; We check for a firmware volume at every 4KB address in the top 16MB
    38                              <1>     ; just below 4GB.  (Addresses at 0xffHHH000 where H is any hex digit.)
    39                              <1>     ;
    40 00000002 2D00100000          <1>     sub     eax, 0x1000
    41 00000007 3D000000FF          <1>     cmp     eax, 0xff000000
    42 0000000C 7259                <1>     jb      searchedForBfvHeaderButNotFound
    43                              <1> 
    44                              <1>     ;
    45                              <1>     ; Check FFS3 GUID
    46                              <1>     ;
    47 0000000E 8178107AC07354      <1>     cmp     dword [eax + 0x10], FFS3_GUID_DWORD0
    48 00000015 751D                <1>     jne     searchingForFfs2Guid
    49 00000017 817814CB3DCA4D      <1>     cmp     dword [eax + 0x14], FFS3_GUID_DWORD1
    50 0000001E 7514                <1>     jne     searchingForFfs2Guid
    51 00000020 817818BD6F1E96      <1>     cmp     dword [eax + 0x18], FFS3_GUID_DWORD2
    52 00000027 750B                <1>     jne     searchingForFfs2Guid
    53 00000029 81781C89E7349A      <1>     cmp     dword [eax + 0x1c], FFS3_GUID_DWORD3
    54 00000030 7502                <1>     jne     searchingForFfs2Guid
    55 00000032 EB24                <1>     jmp     checkingFvLength
    56                              <1> 
    57                              <1> searchingForFfs2Guid:
    58                              <1>     ;
    59                              <1>     ; Check FFS2 GUID
    60                              <1>     ;
    61 00000034 81781078E58C8C      <1>     cmp     dword [eax + 0x10], FFS2_GUID_DWORD0
    62 0000003B 75C5                <1>     jne     searchingForBfvHeaderLoop
    63 0000003D 8178143D8A1C4F      <1>     cmp     dword [eax + 0x14], FFS2_GUID_DWORD1
    64 00000044 75BC                <1>     jne     searchingForBfvHeaderLoop
    65 00000046 81781899358961      <1>     cmp     dword [eax + 0x18], FFS2_GUID_DWORD2
    66 0000004D 75B3                <1>     jne     searchingForBfvHeaderLoop
    67 0000004F 81781C85C32DD3      <1>     cmp     dword [eax + 0x1c], FFS2_GUID_DWORD3
    68 00000056 75AA                <1>     jne     searchingForBfvHeaderLoop
    69                              <1> 
    70                              <1> checkingFvLength:
    71                              <1>     ;
    72                              <1>     ; Check FV Length
    73                              <1>     ;
    74 00000058 83782400            <1>     cmp     dword [eax + 0x24], 0
    75 0000005C 75A4                <1>     jne     searchingForBfvHeaderLoop
    76 0000005E 89C3                <1>     mov     ebx, eax
    77 00000060 035820              <1>     add     ebx, dword [eax + 0x20]
    78 00000063 759D                <1>     jnz     searchingForBfvHeaderLoop
    79                              <1> 
    80 00000065 EB09                <1>     jmp     searchedForBfvHeaderAndItWasFound
    81                              <1> 
    82                              <1> searchedForBfvHeaderButNotFound:
    83                              <1>     ;
    84                              <1>     ; Hang if the SEC entry point was not found
    85                              <1>     ;
    86                              <1>     debugShowPostCode POSTCODE_BFV_NOT_FOUND
    87                              <1> 
    88                              <1>     ;
    89                              <1>     ; 0xbfbfbfbf in the EAX & EBP registers helps signal what failed
    90                              <1>     ; for debugging purposes.
    91                              <1>     ;
    92 00000067 B8BFBFBFBF          <1>     mov     eax, 0xBFBFBFBF
    93 0000006C 89C5                <1>     mov     ebp, eax
    94 0000006E EBFE                <1>     jmp     $
    95                              <1> 
    96                              <1> searchedForBfvHeaderAndItWasFound:
    97 00000070 89C5                <1>     mov     ebp, eax
    98                              <1> 
    99                              <1>     debugShowPostCode POSTCODE_BFV_FOUND
   100                              <1> 
   101                              <1>     OneTimeCallRet Flat32SearchForBfvBase
    19 00000072 E964040000          <2>  jmp %1 %+ OneTimerCallReturn
   102                              <1> 
    52                                  %include "Ia32/SearchForSecEntry.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Search for the SEC Core entry point
     4                              <1> ;
     5                              <1> ; Copyright (c) 2008 - 2011, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> BITS    32
    11                              <1> 
    12                              <1> %define EFI_FV_FILETYPE_SECURITY_CORE         0x03
    13                              <1> 
    14                              <1> ;
    15                              <1> ; Modified:  EAX, EBX, ECX, EDX
    16                              <1> ; Preserved: EDI, EBP, ESP
    17                              <1> ;
    18                              <1> ; @param[in]   EBP  Address of Boot Firmware Volume (BFV)
    19                              <1> ; @param[out]  ESI  SEC Core Entry Point Address
    20                              <1> ;
    21                              <1> Flat32SearchForSecEntryPoint:
    22                              <1> 
    23                              <1>     ;
    24                              <1>     ; Initialize EBP and ESI to 0
    25                              <1>     ;
    26 00000077 31DB                <1>     xor     ebx, ebx
    27 00000079 89DE                <1>     mov     esi, ebx
    28                              <1> 
    29                              <1>     ;
    30                              <1>     ; Pass over the BFV header
    31                              <1>     ;
    32 0000007B 89E8                <1>     mov     eax, ebp
    33 0000007D 668B5D30            <1>     mov     bx, [ebp + 0x30]
    34 00000081 01D8                <1>     add     eax, ebx
    35 00000083 723B                <1>     jc      secEntryPointWasNotFound
    36                              <1> 
    37 00000085 EB03                <1>     jmp     searchingForFfsFileHeaderLoop
    38                              <1> 
    39                              <1> moveForwardWhileSearchingForFfsFileHeaderLoop:
    40                              <1>     ;
    41                              <1>     ; Make forward progress in the search
    42                              <1>     ;
    43 00000087 40                  <1>     inc     eax
    44 00000088 7236                <1>     jc      secEntryPointWasNotFound
    45                              <1> 
    46                              <1> searchingForFfsFileHeaderLoop:
    47 0000008A 85C0                <1>     test    eax, eax
    48 0000008C 7432                <1>     jz      secEntryPointWasNotFound
    49                              <1> 
    50                              <1>     ;
    51                              <1>     ; Ensure 8 byte alignment
    52                              <1>     ;
    53 0000008E 83C007              <1>     add     eax, 7
    54 00000091 722D                <1>     jc      secEntryPointWasNotFound
    55 00000093 24F8                <1>     and     al, 0xf8
    56                              <1> 
    57                              <1>     ;
    58                              <1>     ; Look to see if there is an FFS file at eax
    59                              <1>     ;
    60 00000095 8A5817              <1>     mov     bl, [eax + 0x17]
    61 00000098 F6C320              <1>     test    bl, 0x20
    62 0000009B 74EA                <1>     jz      moveForwardWhileSearchingForFfsFileHeaderLoop
    63 0000009D 8B4814              <1>     mov     ecx, [eax + 0x14]
    64 000000A0 81E1FFFFFF00        <1>     and     ecx, 0x00ffffff
    65 000000A6 09C9                <1>     or      ecx, ecx
    66 000000A8 74DD                <1>     jz      moveForwardWhileSearchingForFfsFileHeaderLoop
    67 000000AA 01C1                <1>     add     ecx, eax
    68 000000AC 7402                <1>     jz      jumpSinceWeFoundTheLastFfsFile
    69 000000AE 72D7                <1>     jc      moveForwardWhileSearchingForFfsFileHeaderLoop
    70                              <1> jumpSinceWeFoundTheLastFfsFile:
    71                              <1> 
    72                              <1>     ;
    73                              <1>     ; There seems to be a valid file at eax
    74                              <1>     ;
    75 000000B0 80781203            <1>     cmp     byte [eax + 0x12], EFI_FV_FILETYPE_SECURITY_CORE ; Check File Type
    76 000000B4 7506                <1>     jne     readyToTryFfsFileAtEcx
    77                              <1> 
    78                              <1> fileTypeIsSecCore:
    79                              <1>     OneTimeCall GetEntryPointOfFfsFile
    14 000000B6 EB17                <2>  jmp %1
    15                              <2> %1 %+ OneTimerCallReturn:
    80 000000B8 85C0                <1>     test    eax, eax
    81 000000BA 7506                <1>     jnz     doneSeachingForSecEntryPoint
    82                              <1> 
    83                              <1> readyToTryFfsFileAtEcx:
    84                              <1>     ;
    85                              <1>     ; Try the next FFS file at ECX
    86                              <1>     ;
    87 000000BC 89C8                <1>     mov     eax, ecx
    88 000000BE EBCA                <1>     jmp     searchingForFfsFileHeaderLoop
    89                              <1> 
    90                              <1> secEntryPointWasNotFound:
    91 000000C0 31C0                <1>     xor     eax, eax
    92                              <1> 
    93                              <1> doneSeachingForSecEntryPoint:
    94 000000C2 89C6                <1>     mov     esi, eax
    95                              <1> 
    96 000000C4 85F6                <1>     test    esi, esi
    97 000000C6 7502                <1>     jnz     secCoreEntryPointWasFound
    98                              <1> 
    99                              <1> secCoreEntryPointWasNotFound:
   100                              <1>     ;
   101                              <1>     ; Hang if the SEC entry point was not found
   102                              <1>     ;
   103                              <1>     debugShowPostCode POSTCODE_SEC_NOT_FOUND
   104 000000C8 74FE                <1>     jz      $
   105                              <1> 
   106                              <1> secCoreEntryPointWasFound:
   107                              <1>     debugShowPostCode POSTCODE_SEC_FOUND
   108                              <1> 
   109                              <1>     OneTimeCallRet Flat32SearchForSecEntryPoint
    19 000000CA E911040000          <2>  jmp %1 %+ OneTimerCallReturn
   110                              <1> 
   111                              <1> %define EFI_SECTION_PE32                  0x10
   112                              <1> %define EFI_SECTION_TE                    0x12
   113                              <1> 
   114                              <1> ;
   115                              <1> ; Input:
   116                              <1> ;   EAX - Start of FFS file
   117                              <1> ;   ECX - End of FFS file
   118                              <1> ;
   119                              <1> ; Output:
   120                              <1> ;   EAX - Entry point of PE32 (or 0 if not found)
   121                              <1> ;
   122                              <1> ; Modified:
   123                              <1> ;   EBX
   124                              <1> ;
   125                              <1> GetEntryPointOfFfsFile:
   126 000000CF 85C0                <1>     test    eax, eax
   127 000000D1 745F                <1>     jz      getEntryPointOfFfsFileErrorReturn
   128 000000D3 83C018              <1>     add     eax, 0x18       ; EAX = Start of section
   129                              <1> 
   130                              <1> getEntryPointOfFfsFileLoopForSections:
   131 000000D6 39C8                <1>     cmp     eax, ecx
   132 000000D8 7358                <1>     jae     getEntryPointOfFfsFileErrorReturn
   133                              <1> 
   134 000000DA 80780310            <1>     cmp     byte [eax + 3], EFI_SECTION_PE32
   135 000000DE 741B                <1>     je      getEntryPointOfFfsFileFoundPe32Section
   136                              <1> 
   137 000000E0 80780312            <1>     cmp     byte [eax + 3], EFI_SECTION_TE
   138 000000E4 7432                <1>     je      getEntryPointOfFfsFileFoundTeSection
   139                              <1> 
   140                              <1>     ;
   141                              <1>     ; The section type was not PE32 or TE, so move to next section
   142                              <1>     ;
   143 000000E6 8B18                <1>     mov     ebx, dword [eax]
   144 000000E8 81E3FFFFFF00        <1>     and     ebx, 0x00ffffff
   145 000000EE 01D8                <1>     add     eax, ebx
   146 000000F0 7240                <1>     jc      getEntryPointOfFfsFileErrorReturn
   147                              <1> 
   148                              <1>     ;
   149                              <1>     ; Ensure that FFS section is 32-bit aligned
   150                              <1>     ;
   151 000000F2 83C003              <1>     add     eax, 3
   152 000000F5 723B                <1>     jc      getEntryPointOfFfsFileErrorReturn
   153 000000F7 24FC                <1>     and     al, 0xfc
   154 000000F9 EBDB                <1>     jmp     getEntryPointOfFfsFileLoopForSections
   155                              <1> 
   156                              <1> getEntryPointOfFfsFileFoundPe32Section:
   157 000000FB 83C004              <1>     add     eax, 4       ; EAX = Start of PE32 image
   158                              <1> 
   159 000000FE 6681384D5A          <1>     cmp     word [eax], 'MZ'
   160 00000103 752D                <1>     jne     getEntryPointOfFfsFileErrorReturn
   161 00000105 0FB7583C            <1>     movzx   ebx, word [eax + 0x3c]
   162 00000109 01C3                <1>     add     ebx, eax
   163                              <1> 
   164                              <1>     ; if (Hdr.Pe32->Signature == EFI_IMAGE_NT_SIGNATURE)
   165 0000010B 813B50450000        <1>     cmp     dword [ebx], `PE\x00\x00`
   166 00000111 751F                <1>     jne     getEntryPointOfFfsFileErrorReturn
   167                              <1> 
   168                              <1>     ; *EntryPoint = (VOID *)((UINTN)Pe32Data +
   169                              <1>     ;   (UINTN)(Hdr.Pe32->OptionalHeader.AddressOfEntryPoint & 0x0ffffffff));
   170 00000113 034328              <1>     add     eax, [ebx + 0x4 + 0x14 + 0x10]
   171 00000116 EB1F                <1>     jmp     getEntryPointOfFfsFileReturn
   172                              <1> 
   173                              <1> getEntryPointOfFfsFileFoundTeSection:
   174 00000118 83C004              <1>     add     eax, 4       ; EAX = Start of TE image
   175 0000011B 89C3                <1>     mov     ebx, eax
   176                              <1> 
   177                              <1>     ; if (Hdr.Te->Signature == EFI_TE_IMAGE_HEADER_SIGNATURE)
   178 0000011D 66813B565A          <1>     cmp     word [ebx], 'VZ'
   179 00000122 750E                <1>     jne     getEntryPointOfFfsFileErrorReturn
   180                              <1>     ; *EntryPoint = (VOID *)((UINTN)Pe32Data +
   181                              <1>     ;   (UINTN)(Hdr.Te->AddressOfEntryPoint & 0x0ffffffff) +
   182                              <1>     ;   sizeof(EFI_TE_IMAGE_HEADER) - Hdr.Te->StrippedSize);
   183 00000124 034308              <1>     add     eax, [ebx + 0x8]
   184 00000127 83C028              <1>     add     eax, 0x28
   185 0000012A 0FB75B06            <1>     movzx   ebx, word [ebx + 0x6]
   186 0000012E 29D8                <1>     sub     eax, ebx
   187 00000130 EB05                <1>     jmp     getEntryPointOfFfsFileReturn
   188                              <1> 
   189                              <1> getEntryPointOfFfsFileErrorReturn:
   190 00000132 B800000000          <1>     mov     eax, 0
   191                              <1> 
   192                              <1> getEntryPointOfFfsFileReturn:
   193                              <1>     OneTimeCallRet GetEntryPointOfFfsFile
    19 00000137 E97CFFFFFF          <2>  jmp %1 %+ OneTimerCallReturn
   194                              <1> 
    53                                  
    54                                  %define WORK_AREA_GUEST_TYPE (000808000h)
    55                                  %define PT_ADDR(Offset) (000800000h + (Offset))
    56                                  %define PG_5_LEVEL (0)
    57                                  
    58                                  %define GHCB_PT_ADDR (00h)
    59                                  %define GHCB_BASE (0)
    60                                  %define GHCB_SIZE (0)
    61                                  %define SEV_ES_WORK_AREA (8421380)
    62                                  %define SEV_ES_WORK_AREA_SIZE 25
    63                                  %define SEV_ES_WORK_AREA_STATUS_MSR (8421380)
    64                                  %define SEV_ES_WORK_AREA_RDRAND (8421380 + 8)
    65                                  %define SEV_ES_WORK_AREA_ENC_MASK (8421380 + 16)
    66                                  %define SEV_ES_WORK_AREA_RECEIVED_VC (8421380 + 24)
    67                                  %define SEV_ES_VC_TOP_OF_STACK (000810000h + 000010000h)
    68                                  %define SEV_SNP_SECRETS_BASE (0)
    69                                  %define SEV_SNP_SECRETS_SIZE (0)
    70                                  %define CPUID_BASE (0)
    71                                  %define CPUID_SIZE (0)
    72                                  %define SVSM_CAA_BASE (0)
    73                                  %define SVSM_CAA_SIZE (0)
    74                                  %if (00h > 0)
    75                                    ; There's a reserved page for SEV secrets and hashes; the VMM will fill and
    76                                    ; validate the page, or mark it as a zero page.
    77                                    %define SEV_SNP_KERNEL_HASHES_BASE (00h)
    78                                    %define SEV_SNP_KERNEL_HASHES_SIZE (00h + 00h)
    79                                  %else
    80                                    %define SEV_SNP_KERNEL_HASHES_BASE 0
    81                                    %define SEV_SNP_KERNEL_HASHES_SIZE 0
    82                                  %endif
    83                                  %define SNP_SEC_MEM_BASE_DESC_1 (000800000h)
    84                                  %define SNP_SEC_MEM_SIZE_DESC_1 (0 - SNP_SEC_MEM_BASE_DESC_1)
    85                                  ;
    86                                  ; The PcdOvmfSecGhcbBase reserves two GHCB pages. The first page is used
    87                                  ; as GHCB shared page and second is used for bookkeeping to support the
    88                                  ; nested GHCB in SEC phase. The bookkeeping page is mapped private. The VMM
    89                                  ; does not need to validate the shared page but it need to validate the
    90                                  ; bookkeeping page.
    91                                  ;
    92                                  %define SNP_SEC_MEM_BASE_DESC_2 (GHCB_BASE + 01000h)
    93                                  %define SNP_SEC_MEM_SIZE_DESC_2 (SEV_SNP_SECRETS_BASE - SNP_SEC_MEM_BASE_DESC_2)
    94                                  %define SNP_SEC_MEM_BASE_DESC_3 (SVSM_CAA_BASE + SVSM_CAA_SIZE + SEV_SNP_KERNEL_HASHES_SIZE)
    95                                  %define SNP_SEC_MEM_SIZE_DESC_3 (000820000h - SNP_SEC_MEM_BASE_DESC_3)
    96                                  
    97                                  %ifdef ARCH_X64
    98                                  
    99                                  
   100                                    %if (000006000h != 06000h)
   101                                      %error "This implementation inherently depends on PcdOvmfSecPageTablesSize"
   102                                    %endif
   103                                  
   104                                    %if (00h != 01000h)
   105                                      %error "This implementation inherently depends on PcdOvmfSecGhcbPageTableSize"
   106                                    %endif
   107                                  
   108                                    %if (0 != 02000h)
   109                                      %error "This implementation inherently depends on PcdOvmfSecGhcbSize"
   110                                    %endif
   111                                  
   112                                    %if ((0 >> 21) != ((0 + 0 - 1) >> 21))
   113                                  
   114                                      %error "This implementation inherently depends on PcdOvmfSecGhcbBase not straddling a 2MB boundary"
   115                                    %endif
   116                                  
   117                                    %define TDX_BFV_RAW_DATA_OFFSET 084000h
   118                                    %define TDX_BFV_RAW_DATA_SIZE 00037C000h
   119                                    %define TDX_BFV_MEMORY_BASE 0FFC84000h
   120                                    %define TDX_BFV_MEMORY_SIZE 00037C000h
   121                                  
   122                                    %define TDX_CFV_RAW_DATA_OFFSET 0
   123                                    %define TDX_CFV_RAW_DATA_SIZE 084000h
   124                                    %define TDX_CFV_MEMORY_BASE 0FFC00000h,
   125                                    %define TDX_CFV_MEMORY_SIZE 084000h,
   126                                  
   127                                    %define TDX_HEAP_STACK_BASE 000810000h
   128                                    %define TDX_HEAP_STACK_SIZE 000010000h
   129                                  
   130                                    %define TDX_HOB_MEMORY_BASE 0
   131                                    %define TDX_HOB_MEMORY_SIZE 0
   132                                  
   133                                    %define TDX_INIT_MEMORY_BASE 000808000h
   134                                    %define TDX_INIT_MEMORY_SIZE (000001000h + 0)
   135                                  
   136                                    %define OVMF_PAGE_TABLE_BASE 000800000h
   137                                    %define OVMF_PAGE_TABLE_SIZE 000006000h
   138                                  
   139                                    %define TDX_WORK_AREA_PGTBL_READY (000808000h + 4)
   140                                    %define TDX_WORK_AREA_GPAW (000808000h + 8)
   141                                  
   142                                    %include "X64/IntelTdxMetadata.asm"
   143                                    %include "Ia32/Flat32ToFlat64.asm"
   144                                    %include "Ia32/PageTables64.asm"
   145                                    %include "Ia32/IntelTdx.asm"
   146                                    %include "X64/OvmfSevMetadata.asm"
   147                                  %endif
   148                                  
   149                                  %include "Ia32/AmdSev.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Provide the functions to check whether SEV and SEV-ES is enabled.
     4                              <1> ;
     5                              <1> ; Copyright (c) 2017 - 2021, Advanced Micro Devices, Inc. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> BITS    32
    11                              <1> 
    12                              <1> ;
    13                              <1> ; SEV-ES #VC exception handler support
    14                              <1> ;
    15                              <1> ; #VC handler local variable locations
    16                              <1> ;
    17                              <1> %define VC_CPUID_RESULT_EAX         0
    18                              <1> %define VC_CPUID_RESULT_EBX         4
    19                              <1> %define VC_CPUID_RESULT_ECX         8
    20                              <1> %define VC_CPUID_RESULT_EDX        12
    21                              <1> %define VC_GHCB_MSR_EDX            16
    22                              <1> %define VC_GHCB_MSR_EAX            20
    23                              <1> %define VC_CPUID_REQUEST_REGISTER  24
    24                              <1> %define VC_CPUID_FUNCTION          28
    25                              <1> 
    26                              <1> ; #VC handler total local variable size
    27                              <1> ;
    28                              <1> %define VC_VARIABLE_SIZE           32
    29                              <1> 
    30                              <1> ; #VC handler GHCB CPUID request/response protocol values
    31                              <1> ;
    32                              <1> %define GHCB_CPUID_REQUEST          4
    33                              <1> %define GHCB_CPUID_RESPONSE         5
    34                              <1> %define GHCB_CPUID_REGISTER_SHIFT  30
    35                              <1> %define CPUID_INSN_LEN              2
    36                              <1> 
    37                              <1> ; #VC handler offsets/sizes for accessing SNP CPUID page
    38                              <1> ;
    39                              <1> %define SNP_CPUID_ENTRY_SZ         48
    40                              <1> %define SNP_CPUID_COUNT             0
    41                              <1> %define SNP_CPUID_ENTRY            16
    42                              <1> %define SNP_CPUID_ENTRY_EAX_IN      0
    43                              <1> %define SNP_CPUID_ENTRY_ECX_IN      4
    44                              <1> %define SNP_CPUID_ENTRY_EAX        24
    45                              <1> %define SNP_CPUID_ENTRY_EBX        28
    46                              <1> %define SNP_CPUID_ENTRY_ECX        32
    47                              <1> %define SNP_CPUID_ENTRY_EDX        36
    48                              <1> 
    49                              <1> 
    50                              <1> %define SEV_GHCB_MSR                0xc0010130
    51                              <1> %define SEV_STATUS_MSR              0xc0010131
    52                              <1> 
    53                              <1> ; The #VC was not for CPUID
    54                              <1> %define TERM_VC_NOT_CPUID           1
    55                              <1> 
    56                              <1> ; The unexpected response code
    57                              <1> %define TERM_UNEXPECTED_RESP_CODE   2
    58                              <1> 
    59                              <1> %define PAGE_PRESENT            0x01
    60                              <1> %define PAGE_READ_WRITE         0x02
    61                              <1> %define PAGE_USER_SUPERVISOR    0x04
    62                              <1> %define PAGE_WRITE_THROUGH      0x08
    63                              <1> %define PAGE_CACHE_DISABLE     0x010
    64                              <1> %define PAGE_ACCESSED          0x020
    65                              <1> %define PAGE_DIRTY             0x040
    66                              <1> %define PAGE_PAT               0x080
    67                              <1> %define PAGE_GLOBAL           0x0100
    68                              <1> %define PAGE_2M_MBO            0x080
    69                              <1> %define PAGE_2M_PAT          0x01000
    70                              <1> 
    71                              <1> %define PAGE_4K_PDE_ATTR (PAGE_ACCESSED +                           PAGE_DIRTY +                           PAGE_READ_WRITE +                           PAGE_PRESENT)
    75                              <1> 
    76                              <1> %define PAGE_PDP_ATTR (PAGE_ACCESSED +                        PAGE_READ_WRITE +                        PAGE_PRESENT)
    79                              <1> 
    80                              <1> 
    81                              <1> ; Macro is used to issue the MSR protocol based VMGEXIT. The caller is
    82                              <1> ; responsible to populate values in the EDX:EAX registers. After the vmmcall
    83                              <1> ; returns, it verifies that the response code matches with the expected
    84                              <1> ; code. If it does not match then terminate the guest. The result of request
    85                              <1> ; is returned in the EDX:EAX.
    86                              <1> ;
    87                              <1> ; args 1:Request code, 2: Response code
    88                              <1> %macro VmgExit 2
    89                              <1>     ;
    90                              <1>     ; Add request code:
    91                              <1>     ;   GHCB_MSR[11:0]  = Request code
    92                              <1>     or      eax, %1
    93                              <1> 
    94                              <1>     mov     ecx, SEV_GHCB_MSR
    95                              <1>     wrmsr
    96                              <1> 
    97                              <1>     ; Issue VMGEXIT - NASM doesn't support the vmmcall instruction in 32-bit
    98                              <1>     ; mode, so work around this by temporarily switching to 64-bit mode.
    99                              <1>     ;
   100                              <1> BITS    64
   101                              <1>     rep     vmmcall
   102                              <1> BITS    32
   103                              <1> 
   104                              <1>     mov     ecx, SEV_GHCB_MSR
   105                              <1>     rdmsr
   106                              <1> 
   107                              <1>     ;
   108                              <1>     ; Verify the reponse code, if it does not match then request to terminate
   109                              <1>     ;   GHCB_MSR[11:0]  = Response code
   110                              <1>     mov     ecx, eax
   111                              <1>     and     ecx, 0xfff
   112                              <1>     cmp     ecx, %2
   113                              <1>     jne     SevEsUnexpectedRespTerminate
   114                              <1> %endmacro
   115                              <1> 
   116                              <1> ; Macro to terminate the guest using the VMGEXIT.
   117                              <1> ; arg 1: reason code
   118                              <1> %macro TerminateVmgExit 1
   119                              <1>     mov     eax, %1
   120                              <1>     ;
   121                              <1>     ; Use VMGEXIT to request termination. At this point the reason code is
   122                              <1>     ; located in EAX, so shift it left 16 bits to the proper location.
   123                              <1>     ;
   124                              <1>     ; EAX[11:0]  => 0x100 - request termination
   125                              <1>     ; EAX[15:12] => 0x1   - OVMF
   126                              <1>     ; EAX[23:16] => 0xXX  - REASON CODE
   127                              <1>     ;
   128                              <1>     shl     eax, 16
   129                              <1>     or      eax, 0x1100
   130                              <1>     xor     edx, edx
   131                              <1>     mov     ecx, SEV_GHCB_MSR
   132                              <1>     wrmsr
   133                              <1>     ;
   134                              <1>     ; Issue VMGEXIT - NASM doesn't support the vmmcall instruction in 32-bit
   135                              <1>     ; mode, so work around this by temporarily switching to 64-bit mode.
   136                              <1>     ;
   137                              <1> BITS    64
   138                              <1>     rep     vmmcall
   139                              <1> BITS    32
   140                              <1> 
   141                              <1>     ;
   142                              <1>     ; We shouldn't come back from the VMGEXIT, but if we do, just loop.
   143                              <1>     ;
   144                              <1> %%TerminateHlt:
   145                              <1>     hlt
   146                              <1>     jmp     %%TerminateHlt
   147                              <1> %endmacro
   148                              <1> 
   149                              <1> ; Terminate the guest due to unexpected response code.
   150                              <1> SevEsUnexpectedRespTerminate:
   151                              <1>     TerminateVmgExit    TERM_UNEXPECTED_RESP_CODE
   119 0000013C B802000000          <2>  mov eax, %1
   120                              <2> 
   121                              <2> 
   122                              <2> 
   123                              <2> 
   124                              <2> 
   125                              <2> 
   126                              <2> 
   127                              <2> 
   128 00000141 C1E010              <2>  shl eax, 16
   129 00000144 0D00110000          <2>  or eax, 0x1100
   130 00000149 31D2                <2>  xor edx, edx
   131 0000014B B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
   132 00000150 0F30                <2>  wrmsr
   133                              <2> 
   134                              <2> 
   135                              <2> 
   136                              <2> 
   137                              <2> BITS 64
   138 00000152 F30F01D9            <2>  rep vmmcall
   139                              <2> BITS 32
   140                              <2> 
   141                              <2> 
   142                              <2> 
   143                              <2> 
   144                              <2> %%TerminateHlt:
   145 00000156 F4                  <2>  hlt
   146 00000157 EBFD                <2>  jmp %%TerminateHlt
   152                              <1> 
   153                              <1> %ifdef ARCH_X64
   154                              <1> 
   155                              <1> ; If SEV-ES is enabled then initialize and make the GHCB page shared
   156                              <1> SevClearPageEncMaskForGhcbPage:
   157                              <1>     ; Check if SEV-ES is enabled
   158                              <1>     mov       ecx, 1
   159                              <1>     bt        [SEV_ES_WORK_AREA_STATUS_MSR], ecx
   160                              <1>     jnc       SevClearPageEncMaskForGhcbPageExit
   161                              <1> 
   162                              <1>     ;
   163                              <1>     ; The initial GHCB will live at GHCB_BASE and needs to be un-encrypted.
   164                              <1>     ; This requires the 2MB page for this range be broken down into 512 4KB
   165                              <1>     ; pages.  All will be marked encrypted, except for the GHCB. Since the
   166                              <1>     ; original PMD entry is no longer a leaf entry, remove the encryption
   167                              <1>     ; bit when pointing to the PTE page.
   168                              <1>     ;
   169                              <1>     mov     ecx, (GHCB_BASE >> 21)
   170                              <1>     mov     eax, GHCB_PT_ADDR + PAGE_PDP_ATTR
   171                              <1>     mov     [ecx * 8 + PT_ADDR (0x2000)], eax
   172                              <1>     mov     [ecx * 8 + PT_ADDR (0x2000) + 4], strict dword 0
   173                              <1> 
   174                              <1>     ;
   175                              <1>     ; Page Table Entries (512 * 4KB entries => 2MB)
   176                              <1>     ;
   177                              <1>     mov     ecx, 512
   178                              <1> pageTableEntries4kLoop:
   179                              <1>     mov     eax, ecx
   180                              <1>     dec     eax
   181                              <1>     shl     eax, 12
   182                              <1>     add     eax, GHCB_BASE & 0xFFE0_0000
   183                              <1>     add     eax, PAGE_4K_PDE_ATTR
   184                              <1>     mov     [ecx * 8 + GHCB_PT_ADDR - 8], eax
   185                              <1>     mov     [(ecx * 8 + GHCB_PT_ADDR - 8) + 4], edx
   186                              <1>     loop    pageTableEntries4kLoop
   187                              <1> 
   188                              <1>     ;
   189                              <1>     ; Clear the encryption bit from the GHCB entry
   190                              <1>     ;
   191                              <1>     mov     ecx, (GHCB_BASE & 0x1F_FFFF) >> 12
   192                              <1>     mov     [ecx * 8 + GHCB_PT_ADDR + 4], strict dword 0
   193                              <1> 
   194                              <1> SevClearPageEncMaskForGhcbPageExit:
   195                              <1>     OneTimeCallRet SevClearPageEncMaskForGhcbPage
   196                              <1> 
   197                              <1> ; Get the C-bit mask above 31.
   198                              <1> ; Modified: EDX
   199                              <1> ;
   200                              <1> ; The value is returned in the EDX
   201                              <1> GetSevCBitMaskAbove31:
   202                              <1>     mov       edx, dword[SEV_ES_WORK_AREA_ENC_MASK + 4]
   203                              <1>     OneTimeCallRet GetSevCBitMaskAbove31
   204                              <1> 
   205                              <1> %endif
   206                              <1> 
   207                              <1> ; Check if Secure Encrypted Virtualization (SEV) features are enabled.
   208                              <1> ;
   209                              <1> ; Register usage is tight in this routine, so multiple calls for the
   210                              <1> ; same CPUID and MSR data are performed to keep things simple.
   211                              <1> ;
   212                              <1> ; Modified:  EAX, EBX, ECX, EDX, ESP
   213                              <1> ;
   214                              <1> ; If SEV is enabled then EAX will be at least 32.
   215                              <1> ; If SEV is disabled then EAX will be zero.
   216                              <1> ;
   217                              <1> CheckSevFeatures:
   218                              <1>     ;
   219                              <1>     ; Clear the workarea, if SEV is enabled then later part of routine
   220                              <1>     ; will populate the workarea fields.
   221                              <1>     ;
   222 00000159 B919000000          <1>     mov    ecx, SEV_ES_WORK_AREA_SIZE
   223 0000015E B804808000          <1>     mov    eax, SEV_ES_WORK_AREA
   224                              <1> ClearSevEsWorkArea:
   225 00000163 C60000              <1>     mov    byte [eax], 0
   226 00000166 40                  <1>     inc    eax
   227 00000167 E2FA                <1>     loop   ClearSevEsWorkArea
   228                              <1> 
   229                              <1>     ;
   230                              <1>     ; Set up exception handlers to check for SEV-ES
   231                              <1>     ;   Load temporary RAM stack based on PCDs (see SevEsIdtVmmComm for
   232                              <1>     ;   stack usage)
   233                              <1>     ;   Establish exception handlers
   234                              <1>     ;
   235 00000169 BC00008200          <1>     mov       esp, SEV_ES_VC_TOP_OF_STACK
   236 0000016E B8C4FDFFFF          <1>     mov       eax, ADDR_OF(Idtr)
   237 00000173 2E0F0118            <1>     lidt      [cs:eax]
   238                              <1> 
   239                              <1>     ; Check if we have a valid (0x8000_001F) CPUID leaf
   240                              <1>     ;   CPUID raises a #VC exception if running as an SEV-ES guest
   241 00000177 B800000080          <1>     mov       eax, 0x80000000
   242 0000017C 0FA2                <1>     cpuid
   243                              <1> 
   244                              <1>     ; This check should fail on Intel or Non SEV AMD CPUs. In future if
   245                              <1>     ; Intel CPUs supports this CPUID leaf then we are guranteed to have exact
   246                              <1>     ; same bit definition.
   247 0000017E 3D1F000080          <1>     cmp       eax, 0x8000001f
   248 00000183 7C5E                <1>     jl        NoSev
   249                              <1> 
   250                              <1>     ; Check for SEV memory encryption feature:
   251                              <1>     ; CPUID  Fn8000_001F[EAX] - Bit 1
   252                              <1>     ;   CPUID raises a #VC exception if running as an SEV-ES guest
   253 00000185 B81F000080          <1>     mov       eax, 0x8000001f
   254 0000018A 0FA2                <1>     cpuid
   255 0000018C 0FBAE001            <1>     bt        eax, 1
   256 00000190 7351                <1>     jnc       NoSev
   257                              <1> 
   258                              <1>     ; Check if SEV memory encryption is enabled
   259                              <1>     ;  MSR_0xC0010131 - Bit 0 (SEV enabled)
   260 00000192 B9310101C0          <1>     mov       ecx, SEV_STATUS_MSR
   261 00000197 0F32                <1>     rdmsr
   262 00000199 0FBAE000            <1>     bt        eax, 0
   263 0000019D 7344                <1>     jnc       NoSev
   264                              <1> 
   265                              <1>     ; Set the work area header to indicate that the SEV is enabled
   266 0000019F C6050080800001      <1>     mov     byte[WORK_AREA_GUEST_TYPE], 1
   267                              <1> 
   268                              <1>     ; Save the SevStatus MSR value in the workarea
   269 000001A6 A304808000          <1>     mov     [SEV_ES_WORK_AREA_STATUS_MSR], eax
   270 000001AB 891508808000        <1>     mov     [SEV_ES_WORK_AREA_STATUS_MSR + 4], edx
   271                              <1> 
   272                              <1>     ; Check if SEV-ES is enabled
   273                              <1>     ;  MSR_0xC0010131 - Bit 1 (SEV-ES enabled)
   274 000001B1 B9310101C0          <1>     mov       ecx, SEV_STATUS_MSR
   275 000001B6 0F32                <1>     rdmsr
   276 000001B8 0FBAE001            <1>     bt        eax, 1
   277 000001BC 7300                <1>     jnc       GetSevEncBit
   278                              <1> 
   279                              <1> GetSevEncBit:
   280                              <1>     ; Get pte bit position to enable memory encryption
   281                              <1>     ; CPUID Fn8000_001F[EBX] - Bits 5:0
   282                              <1>     ;
   283 000001BE 83E33F              <1>     and       ebx, 0x3f
   284 000001C1 89D8                <1>     mov       eax, ebx
   285                              <1> 
   286                              <1>     ; The encryption bit position is always above 31
   287 000001C3 83EB20              <1>     sub       ebx, 32
   288 000001C6 7904                <1>     jns       SevSaveMask
   289                              <1> 
   290                              <1>     ; Encryption bit was reported as 31 or below, enter a HLT loop
   291                              <1> SevEncBitLowHlt:
   292 000001C8 FA                  <1>     cli
   293 000001C9 F4                  <1>     hlt
   294 000001CA EBFC                <1>     jmp       SevEncBitLowHlt
   295                              <1> 
   296                              <1> SevSaveMask:
   297 000001CC 31D2                <1>     xor       edx, edx
   298 000001CE 0FABDA              <1>     bts       edx, ebx
   299                              <1> 
   300 000001D1 C70514808000000000- <1>     mov       dword[SEV_ES_WORK_AREA_ENC_MASK], 0
   300 000001DA 00                  <1>
   301 000001DB 891518808000        <1>     mov       dword[SEV_ES_WORK_AREA_ENC_MASK + 4], edx
   302 000001E1 EB0F                <1>     jmp       SevExit
   303                              <1> 
   304                              <1> NoSev:
   305                              <1>     ;
   306                              <1>     ; Perform an SEV-ES sanity check by seeing if a #VC exception occurred.
   307                              <1>     ;
   308                              <1>     ; If SEV-ES is enabled, the CPUID instruction will trigger a #VC exception
   309                              <1>     ; where the RECEIVED_VC offset in the workarea will be set to one.
   310                              <1>     ;
   311 000001E3 803D1C80800000      <1>     cmp       byte[SEV_ES_WORK_AREA_RECEIVED_VC], 0
   312 000001EA 7404                <1>     jz        NoSevPass
   313                              <1> 
   314                              <1>     ;
   315                              <1>     ; A #VC was received, yet CPUID indicates no SEV-ES support, something
   316                              <1>     ; isn't right.
   317                              <1>     ;
   318                              <1> NoSevEsVcHlt:
   319 000001EC FA                  <1>     cli
   320 000001ED F4                  <1>     hlt
   321 000001EE EBFC                <1>     jmp       NoSevEsVcHlt
   322                              <1> 
   323                              <1> NoSevPass:
   324 000001F0 31C0                <1>     xor       eax, eax
   325                              <1> 
   326                              <1> SevExit:
   327                              <1>     ;
   328                              <1>     ; Clear exception handlers and stack
   329                              <1>     ;
   330 000001F2 50                  <1>     push      eax
   331 000001F3 B8CAFDFFFF          <1>     mov       eax, ADDR_OF(IdtrClear)
   332 000001F8 2E0F0118            <1>     lidt      [cs:eax]
   333 000001FC 58                  <1>     pop       eax
   334 000001FD BC00000000          <1>     mov       esp, 0
   335                              <1> 
   336                              <1>     OneTimeCallRet CheckSevFeatures
    19 00000202 E9DE020000          <2>  jmp %1 %+ OneTimerCallReturn
   337                              <1> 
   338                              <1> ; Start of #VC exception handling routines
   339                              <1> ;
   340                              <1> 
   341                              <1> SevEsIdtNotCpuid:
   342                              <1>     TerminateVmgExit TERM_VC_NOT_CPUID
   119 00000207 B801000000          <2>  mov eax, %1
   120                              <2> 
   121                              <2> 
   122                              <2> 
   123                              <2> 
   124                              <2> 
   125                              <2> 
   126                              <2> 
   127                              <2> 
   128 0000020C C1E010              <2>  shl eax, 16
   129 0000020F 0D00110000          <2>  or eax, 0x1100
   130 00000214 31D2                <2>  xor edx, edx
   131 00000216 B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
   132 0000021B 0F30                <2>  wrmsr
   133                              <2> 
   134                              <2> 
   135                              <2> 
   136                              <2> 
   137                              <2> BITS 64
   138 0000021D F30F01D9            <2>  rep vmmcall
   139                              <2> BITS 32
   140                              <2> 
   141                              <2> 
   142                              <2> 
   143                              <2> 
   144                              <2> %%TerminateHlt:
   145 00000221 F4                  <2>  hlt
   146 00000222 EBFD                <2>  jmp %%TerminateHlt
   343 00000224 CF                  <1>     iret
   344                              <1> 
   345                              <1> ; Use the SNP CPUID page to handle the cpuid lookup
   346                              <1> ;
   347                              <1> ;  Modified: EAX, EBX, ECX, EDX
   348                              <1> ;
   349                              <1> ;  Relies on the stack setup/usage in #VC handler:
   350                              <1> ;
   351                              <1> ;    On entry,
   352                              <1> ;      [esp + VC_CPUID_FUNCTION] contains EAX input to cpuid instruction
   353                              <1> ;
   354                              <1> ;    On return, stores corresponding results of CPUID lookup in:
   355                              <1> ;      [esp + VC_CPUID_RESULT_EAX]
   356                              <1> ;      [esp + VC_CPUID_RESULT_EBX]
   357                              <1> ;      [esp + VC_CPUID_RESULT_ECX]
   358                              <1> ;      [esp + VC_CPUID_RESULT_EDX]
   359                              <1> ;
   360                              <1> SnpCpuidLookup:
   361 00000225 8B44241C            <1>     mov     eax, [esp + VC_CPUID_FUNCTION]
   362 00000229 8B1D00000000        <1>     mov     ebx, [CPUID_BASE + SNP_CPUID_COUNT]
   363 0000022F B910000000          <1>     mov     ecx, CPUID_BASE + SNP_CPUID_ENTRY
   364                              <1>     ; Zero these out now so we can simply return if lookup fails
   365 00000234 C7042400000000      <1>     mov     dword[esp + VC_CPUID_RESULT_EAX], 0
   366 0000023B C744240400000000    <1>     mov     dword[esp + VC_CPUID_RESULT_EBX], 0
   367 00000243 C744240800000000    <1>     mov     dword[esp + VC_CPUID_RESULT_ECX], 0
   368 0000024B C744240C00000000    <1>     mov     dword[esp + VC_CPUID_RESULT_EDX], 0
   369                              <1> 
   370                              <1> SnpCpuidCheckEntry:
   371 00000253 83FB00              <1>     cmp     ebx, 0
   372 00000256 0F84C0000000        <1>     je      VmmDoneSnpCpuid
   373 0000025C 3901                <1>     cmp     dword[ecx + SNP_CPUID_ENTRY_EAX_IN], eax
   374 0000025E 7506                <1>     jne     SnpCpuidCheckEntryNext
   375                              <1>     ; As with SEV-ES handler we assume requested CPUID sub-leaf/index is 0
   376 00000260 83790400            <1>     cmp     dword[ecx + SNP_CPUID_ENTRY_ECX_IN], 0
   377 00000264 7406                <1>     je      SnpCpuidEntryFound
   378                              <1> 
   379                              <1> SnpCpuidCheckEntryNext:
   380 00000266 4B                  <1>     dec     ebx
   381 00000267 83C130              <1>     add     ecx, SNP_CPUID_ENTRY_SZ
   382 0000026A EBE7                <1>     jmp     SnpCpuidCheckEntry
   383                              <1> 
   384                              <1> SnpCpuidEntryFound:
   385 0000026C 8B4118              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_EAX]
   386 0000026F 890424              <1>     mov     [esp + VC_CPUID_RESULT_EAX], eax
   387 00000272 8B411C              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_EBX]
   388 00000275 89442404            <1>     mov     [esp + VC_CPUID_RESULT_EBX], eax
   389 00000279 8B4120              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_ECX]
   390 0000027C 89442408            <1>     mov     [esp + VC_CPUID_RESULT_ECX], eax
   391 00000280 8B4124              <1>     mov     eax, [ecx + SNP_CPUID_ENTRY_EDX]
   392 00000283 8944240C            <1>     mov     [esp + VC_CPUID_RESULT_EDX], eax
   393 00000287 E990000000          <1>     jmp     VmmDoneSnpCpuid
   394                              <1> 
   395                              <1> ;
   396                              <1> ; Total stack usage for the #VC handler is 44 bytes:
   397                              <1> ;   - 12 bytes for the exception IRET (after popping error code)
   398                              <1> ;   - 32 bytes for the local variables.
   399                              <1> ;
   400                              <1> SevEsIdtVmmComm:
   401                              <1>     ;
   402                              <1>     ; If we're here, then we are an SEV-ES guest and this
   403                              <1>     ; was triggered by a CPUID instruction
   404                              <1>     ;
   405                              <1>     ; Set the recievedVc field in the workarea to communicate that
   406                              <1>     ; a #VC was taken.
   407 0000028C C6051C80800001      <1>     mov     byte[SEV_ES_WORK_AREA_RECEIVED_VC], 1
   408                              <1> 
   409 00000293 59                  <1>     pop     ecx                     ; Error code
   410 00000294 83F972              <1>     cmp     ecx, 0x72               ; Be sure it was CPUID
   411 00000297 0F856AFFFFFF        <1>     jne     SevEsIdtNotCpuid
   412                              <1> 
   413                              <1>     ; Set up local variable room on the stack
   414                              <1>     ;   CPUID function         : + 28
   415                              <1>     ;   CPUID request register : + 24
   416                              <1>     ;   GHCB MSR (EAX)         : + 20
   417                              <1>     ;   GHCB MSR (EDX)         : + 16
   418                              <1>     ;   CPUID result (EDX)     : + 12
   419                              <1>     ;   CPUID result (ECX)     : + 8
   420                              <1>     ;   CPUID result (EBX)     : + 4
   421                              <1>     ;   CPUID result (EAX)     : + 0
   422 0000029D 83EC20              <1>     sub     esp, VC_VARIABLE_SIZE
   423                              <1> 
   424                              <1>     ; Save the CPUID function being requested
   425 000002A0 8944241C            <1>     mov     [esp + VC_CPUID_FUNCTION], eax
   426                              <1> 
   427                              <1>     ; If SEV-SNP is enabled, use the CPUID page to handle the CPUID
   428                              <1>     ; instruction.
   429 000002A4 B9310101C0          <1>     mov     ecx, SEV_STATUS_MSR
   430 000002A9 0F32                <1>     rdmsr
   431 000002AB 0FBAE002            <1>     bt      eax, 2
   432 000002AF 0F8270FFFFFF        <1>     jc      SnpCpuidLookup
   433                              <1> 
   434                              <1>     ; The GHCB CPUID protocol uses the following mapping to request
   435                              <1>     ; a specific register:
   436                              <1>     ;   0 => EAX, 1 => EBX, 2 => ECX, 3 => EDX
   437                              <1>     ;
   438                              <1>     ; Set EAX as the first register to request. This will also be used as a
   439                              <1>     ; loop variable to request all register values (EAX to EDX).
   440 000002B5 31C0                <1>     xor     eax, eax
   441 000002B7 89442418            <1>     mov     [esp + VC_CPUID_REQUEST_REGISTER], eax
   442                              <1> 
   443                              <1>     ; Save current GHCB MSR value
   444 000002BB B9300101C0          <1>     mov     ecx, SEV_GHCB_MSR
   445 000002C0 0F32                <1>     rdmsr
   446 000002C2 89442414            <1>     mov     [esp + VC_GHCB_MSR_EAX], eax
   447 000002C6 89542410            <1>     mov     [esp + VC_GHCB_MSR_EDX], edx
   448                              <1> 
   449                              <1> NextReg:
   450                              <1>     ;
   451                              <1>     ; Setup GHCB MSR
   452                              <1>     ;   GHCB_MSR[63:32] = CPUID function
   453                              <1>     ;   GHCB_MSR[31:30] = CPUID register
   454                              <1>     ;   GHCB_MSR[11:0]  = CPUID request protocol
   455                              <1>     ;
   456 000002CA 8B442418            <1>     mov     eax, [esp + VC_CPUID_REQUEST_REGISTER]
   457 000002CE 83F804              <1>     cmp     eax, 4
   458 000002D1 7D3A                <1>     jge     VmmDone
   459                              <1> 
   460 000002D3 C1E01E              <1>     shl     eax, GHCB_CPUID_REGISTER_SHIFT
   461 000002D6 8B54241C            <1>     mov     edx, [esp + VC_CPUID_FUNCTION]
   462                              <1> 
   463                              <1>     VmgExit GHCB_CPUID_REQUEST, GHCB_CPUID_RESPONSE
    89                              <2> 
    90                              <2> 
    91                              <2> 
    92 000002DA 83C804              <2>  or eax, %1
    93                              <2> 
    94 000002DD B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
    95 000002E2 0F30                <2>  wrmsr
    96                              <2> 
    97                              <2> 
    98                              <2> 
    99                              <2> 
   100                              <2> BITS 64
   101 000002E4 F30F01D9            <2>  rep vmmcall
   102                              <2> BITS 32
   103                              <2> 
   104 000002E8 B9300101C0          <2>  mov ecx, SEV_GHCB_MSR
   105 000002ED 0F32                <2>  rdmsr
   106                              <2> 
   107                              <2> 
   108                              <2> 
   109                              <2> 
   110 000002EF 89C1                <2>  mov ecx, eax
   111 000002F1 81E1FF0F0000        <2>  and ecx, 0xfff
   112 000002F7 83F905              <2>  cmp ecx, %2
   113 000002FA 0F853CFEFFFF        <2>  jne SevEsUnexpectedRespTerminate
   464                              <1> 
   465                              <1>     ;
   466                              <1>     ; Response GHCB MSR
   467                              <1>     ;   GHCB_MSR[63:32] = CPUID register value
   468                              <1>     ;   GHCB_MSR[31:30] = CPUID register
   469                              <1>     ;   GHCB_MSR[11:0]  = CPUID response protocol
   470                              <1>     ;
   471                              <1> 
   472                              <1>     ; Save returned value
   473 00000300 C1E81E              <1>     shr     eax, GHCB_CPUID_REGISTER_SHIFT
   474 00000303 891484              <1>     mov     [esp + eax * 4], edx
   475                              <1> 
   476                              <1>     ; Next register
   477 00000306 66FF442418          <1>     inc     word [esp + VC_CPUID_REQUEST_REGISTER]
   478                              <1> 
   479 0000030B EBBD                <1>     jmp     NextReg
   480                              <1> 
   481                              <1> VmmDone:
   482                              <1>     ;
   483                              <1>     ; At this point we have all CPUID register values. Restore the GHCB MSR,
   484                              <1>     ; set the return register values and return.
   485                              <1>     ;
   486 0000030D 8B442414            <1>     mov     eax, [esp + VC_GHCB_MSR_EAX]
   487 00000311 8B542410            <1>     mov     edx, [esp + VC_GHCB_MSR_EDX]
   488 00000315 B9300101C0          <1>     mov     ecx, SEV_GHCB_MSR
   489 0000031A 0F30                <1>     wrmsr
   490                              <1> 
   491                              <1> VmmDoneSnpCpuid:
   492 0000031C 8B0424              <1>     mov     eax, [esp + VC_CPUID_RESULT_EAX]
   493 0000031F 8B5C2404            <1>     mov     ebx, [esp + VC_CPUID_RESULT_EBX]
   494 00000323 8B4C2408            <1>     mov     ecx, [esp + VC_CPUID_RESULT_ECX]
   495 00000327 8B54240C            <1>     mov     edx, [esp + VC_CPUID_RESULT_EDX]
   496                              <1> 
   497 0000032B 83C420              <1>     add     esp, VC_VARIABLE_SIZE
   498                              <1> 
   499                              <1>     ; Update the EIP value to skip over the now handled CPUID instruction
   500                              <1>     ; (the CPUID instruction has a length of 2)
   501 0000032E 6683042402          <1>     add     word [esp], CPUID_INSN_LEN
   502 00000333 CF                  <1>     iret
   503                              <1> 
   504                              <1> ALIGN   2
   505                              <1> 
   506                              <1> Idtr:
   507 00000334 FF00                <1>     dw      IDT_END - IDT_BASE - 1  ; Limit
   508 00000336 D0FDFFFF            <1>     dd      ADDR_OF(IDT_BASE)       ; Base
   509                              <1> 
   510                              <1> IdtrClear:
   511 0000033A 0000                <1>     dw      0                       ; Limit
   512 0000033C 00000000            <1>     dd      0                       ; Base
   513                              <1> 
   514                              <1> ALIGN   16
   515                              <1> 
   516                              <1> ;
   517                              <1> ; The Interrupt Descriptor Table (IDT)
   518                              <1> ;   This will be used to determine if SEV-ES is enabled.  Upon execution
   519                              <1> ;   of the CPUID instruction, a VMM Communication Exception will occur.
   520                              <1> ;   This will tell us if SEV-ES is enabled.  We can use the current value
   521                              <1> ;   of the GHCB MSR to determine the SEV attributes.
   522                              <1> ;
   523                              <1> IDT_BASE:
   524                              <1> ;
   525                              <1> ; Vectors 0 - 28 (No handlers)
   526                              <1> ;
   527                              <1> %rep 29
   528                              <1>     dw      0                                    ; Offset low bits 15..0
   529                              <1>     dw      0x10                                 ; Selector
   530                              <1>     db      0                                    ; Reserved
   531                              <1>     db      0x8E                                 ; Gate Type (IA32_IDT_GATE_TYPE_INTERRUPT_32)
   532                              <1>     dw      0                                    ; Offset high bits 31..16
   533                              <1> %endrep
   528 00000340 0000                <2>  dw 0
   529 00000342 1000                <2>  dw 0x10
   530 00000344 00                  <2>  db 0
   531 00000345 8E                  <2>  db 0x8E
   532 00000346 0000                <2>  dw 0
   528 00000348 0000                <2>  dw 0
   529 0000034A 1000                <2>  dw 0x10
   530 0000034C 00                  <2>  db 0
   531 0000034D 8E                  <2>  db 0x8E
   532 0000034E 0000                <2>  dw 0
   528 00000350 0000                <2>  dw 0
   529 00000352 1000                <2>  dw 0x10
   530 00000354 00                  <2>  db 0
   531 00000355 8E                  <2>  db 0x8E
   532 00000356 0000                <2>  dw 0
   528 00000358 0000                <2>  dw 0
   529 0000035A 1000                <2>  dw 0x10
   530 0000035C 00                  <2>  db 0
   531 0000035D 8E                  <2>  db 0x8E
   532 0000035E 0000                <2>  dw 0
   528 00000360 0000                <2>  dw 0
   529 00000362 1000                <2>  dw 0x10
   530 00000364 00                  <2>  db 0
   531 00000365 8E                  <2>  db 0x8E
   532 00000366 0000                <2>  dw 0
   528 00000368 0000                <2>  dw 0
   529 0000036A 1000                <2>  dw 0x10
   530 0000036C 00                  <2>  db 0
   531 0000036D 8E                  <2>  db 0x8E
   532 0000036E 0000                <2>  dw 0
   528 00000370 0000                <2>  dw 0
   529 00000372 1000                <2>  dw 0x10
   530 00000374 00                  <2>  db 0
   531 00000375 8E                  <2>  db 0x8E
   532 00000376 0000                <2>  dw 0
   528 00000378 0000                <2>  dw 0
   529 0000037A 1000                <2>  dw 0x10
   530 0000037C 00                  <2>  db 0
   531 0000037D 8E                  <2>  db 0x8E
   532 0000037E 0000                <2>  dw 0
   528 00000380 0000                <2>  dw 0
   529 00000382 1000                <2>  dw 0x10
   530 00000384 00                  <2>  db 0
   531 00000385 8E                  <2>  db 0x8E
   532 00000386 0000                <2>  dw 0
   528 00000388 0000                <2>  dw 0
   529 0000038A 1000                <2>  dw 0x10
   530 0000038C 00                  <2>  db 0
   531 0000038D 8E                  <2>  db 0x8E
   532 0000038E 0000                <2>  dw 0
   528 00000390 0000                <2>  dw 0
   529 00000392 1000                <2>  dw 0x10
   530 00000394 00                  <2>  db 0
   531 00000395 8E                  <2>  db 0x8E
   532 00000396 0000                <2>  dw 0
   528 00000398 0000                <2>  dw 0
   529 0000039A 1000                <2>  dw 0x10
   530 0000039C 00                  <2>  db 0
   531 0000039D 8E                  <2>  db 0x8E
   532 0000039E 0000                <2>  dw 0
   528 000003A0 0000                <2>  dw 0
   529 000003A2 1000                <2>  dw 0x10
   530 000003A4 00                  <2>  db 0
   531 000003A5 8E                  <2>  db 0x8E
   532 000003A6 0000                <2>  dw 0
   528 000003A8 0000                <2>  dw 0
   529 000003AA 1000                <2>  dw 0x10
   530 000003AC 00                  <2>  db 0
   531 000003AD 8E                  <2>  db 0x8E
   532 000003AE 0000                <2>  dw 0
   528 000003B0 0000                <2>  dw 0
   529 000003B2 1000                <2>  dw 0x10
   530 000003B4 00                  <2>  db 0
   531 000003B5 8E                  <2>  db 0x8E
   532 000003B6 0000                <2>  dw 0
   528 000003B8 0000                <2>  dw 0
   529 000003BA 1000                <2>  dw 0x10
   530 000003BC 00                  <2>  db 0
   531 000003BD 8E                  <2>  db 0x8E
   532 000003BE 0000                <2>  dw 0
   528 000003C0 0000                <2>  dw 0
   529 000003C2 1000                <2>  dw 0x10
   530 000003C4 00                  <2>  db 0
   531 000003C5 8E                  <2>  db 0x8E
   532 000003C6 0000                <2>  dw 0
   528 000003C8 0000                <2>  dw 0
   529 000003CA 1000                <2>  dw 0x10
   530 000003CC 00                  <2>  db 0
   531 000003CD 8E                  <2>  db 0x8E
   532 000003CE 0000                <2>  dw 0
   528 000003D0 0000                <2>  dw 0
   529 000003D2 1000                <2>  dw 0x10
   530 000003D4 00                  <2>  db 0
   531 000003D5 8E                  <2>  db 0x8E
   532 000003D6 0000                <2>  dw 0
   528 000003D8 0000                <2>  dw 0
   529 000003DA 1000                <2>  dw 0x10
   530 000003DC 00                  <2>  db 0
   531 000003DD 8E                  <2>  db 0x8E
   532 000003DE 0000                <2>  dw 0
   528 000003E0 0000                <2>  dw 0
   529 000003E2 1000                <2>  dw 0x10
   530 000003E4 00                  <2>  db 0
   531 000003E5 8E                  <2>  db 0x8E
   532 000003E6 0000                <2>  dw 0
   528 000003E8 0000                <2>  dw 0
   529 000003EA 1000                <2>  dw 0x10
   530 000003EC 00                  <2>  db 0
   531 000003ED 8E                  <2>  db 0x8E
   532 000003EE 0000                <2>  dw 0
   528 000003F0 0000                <2>  dw 0
   529 000003F2 1000                <2>  dw 0x10
   530 000003F4 00                  <2>  db 0
   531 000003F5 8E                  <2>  db 0x8E
   532 000003F6 0000                <2>  dw 0
   528 000003F8 0000                <2>  dw 0
   529 000003FA 1000                <2>  dw 0x10
   530 000003FC 00                  <2>  db 0
   531 000003FD 8E                  <2>  db 0x8E
   532 000003FE 0000                <2>  dw 0
   528 00000400 0000                <2>  dw 0
   529 00000402 1000                <2>  dw 0x10
   530 00000404 00                  <2>  db 0
   531 00000405 8E                  <2>  db 0x8E
   532 00000406 0000                <2>  dw 0
   528 00000408 0000                <2>  dw 0
   529 0000040A 1000                <2>  dw 0x10
   530 0000040C 00                  <2>  db 0
   531 0000040D 8E                  <2>  db 0x8E
   532 0000040E 0000                <2>  dw 0
   528 00000410 0000                <2>  dw 0
   529 00000412 1000                <2>  dw 0x10
   530 00000414 00                  <2>  db 0
   531 00000415 8E                  <2>  db 0x8E
   532 00000416 0000                <2>  dw 0
   528 00000418 0000                <2>  dw 0
   529 0000041A 1000                <2>  dw 0x10
   530 0000041C 00                  <2>  db 0
   531 0000041D 8E                  <2>  db 0x8E
   532 0000041E 0000                <2>  dw 0
   528 00000420 0000                <2>  dw 0
   529 00000422 1000                <2>  dw 0x10
   530 00000424 00                  <2>  db 0
   531 00000425 8E                  <2>  db 0x8E
   532 00000426 0000                <2>  dw 0
   534                              <1> ;
   535                              <1> ; Vector 29 (VMM Communication Exception)
   536                              <1> ;
   537 00000428 1CFD                <1>     dw      (ADDR_OF(SevEsIdtVmmComm) & 0xffff)  ; Offset low bits 15..0
   538 0000042A 1000                <1>     dw      0x10                                 ; Selector
   539 0000042C 00                  <1>     db      0                                    ; Reserved
   540 0000042D 8E                  <1>     db      0x8E                                 ; Gate Type (IA32_IDT_GATE_TYPE_INTERRUPT_32)
   541 0000042E FFFF                <1>     dw      (ADDR_OF(SevEsIdtVmmComm) >> 16)     ; Offset high bits 31..16
   542                              <1> ;
   543                              <1> ; Vectors 30 - 31 (No handlers)
   544                              <1> ;
   545                              <1> %rep 2
   546                              <1>     dw      0                                    ; Offset low bits 15..0
   547                              <1>     dw      0x10                                 ; Selector
   548                              <1>     db      0                                    ; Reserved
   549                              <1>     db      0x8E                                 ; Gate Type (IA32_IDT_GATE_TYPE_INTERRUPT_32)
   550                              <1>     dw      0                                    ; Offset high bits 31..16
   551                              <1> %endrep
   546 00000430 0000                <2>  dw 0
   547 00000432 1000                <2>  dw 0x10
   548 00000434 00                  <2>  db 0
   549 00000435 8E                  <2>  db 0x8E
   550 00000436 0000                <2>  dw 0
   546 00000438 0000                <2>  dw 0
   547 0000043A 1000                <2>  dw 0x10
   548 0000043C 00                  <2>  db 0
   549 0000043D 8E                  <2>  db 0x8E
   550 0000043E 0000                <2>  dw 0
   552                              <1> IDT_END:
   150                                  
   151                                  %include "Ia16/Real16ToFlat32.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Transition from 16 bit real mode into 32 bit flat protected mode
     4                              <1> ;
     5                              <1> ; Copyright (c) 2008 - 2022, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> %define SEC_DEFAULT_CR0  0x00000023
    11                              <1> %define SEC_DEFAULT_CR4  0x640
    12                              <1> 
    13                              <1> BITS    16
    14                              <1> 
    15                              <1> ;
    16                              <1> ; Modified:  EAX, EBX
    17                              <1> ;
    18                              <1> ; @param[out]     DS       Selector allowing flat access to all addresses
    19                              <1> ; @param[out]     ES       Selector allowing flat access to all addresses
    20                              <1> ; @param[out]     FS       Selector allowing flat access to all addresses
    21                              <1> ; @param[out]     GS       Selector allowing flat access to all addresses
    22                              <1> ; @param[out]     SS       Selector allowing flat access to all addresses
    23                              <1> ;
    24                              <1> TransitionFromReal16To32BitFlat:
    25                              <1> 
    26                              <1>     debugShowPostCode POSTCODE_16BIT_MODE
    27                              <1> 
    28 00000440 FA                  <1>     cli
    29                              <1> 
    30 00000441 BB00F0              <1>     mov     bx, 0xf000
    31 00000444 8EDB                <1>     mov     ds, bx
    32                              <1> 
    33 00000446 BB08FF              <1>     mov     bx, ADDR16_OF(gdtr)
    34                              <1> 
    35 00000449 2E660F0117          <1> o32 lgdt    [cs:bx]
    36                              <1> 
    37 0000044E 66B823000000        <1>     mov     eax, SEC_DEFAULT_CR0
    38 00000454 0F22C0              <1>     mov     cr0, eax
    39                              <1> 
    40 00000457 66EAEFFEFFFF1000    <1>     jmp     LINEAR_CODE_SEL:dword ADDR_OF(jumpTo32BitAndLandHere)
    41                              <1> BITS    32
    42                              <1> jumpTo32BitAndLandHere:
    43                              <1> 
    44 0000045F B840060000          <1>     mov     eax, SEC_DEFAULT_CR4
    45 00000464 0F22E0              <1>     mov     cr4, eax
    46                              <1> 
    47                              <1>     debugShowPostCode POSTCODE_32BIT_MODE
    48                              <1> 
    49 00000467 66B81800            <1>     mov     ax, LINEAR_SEL
    50 0000046B 8ED8                <1>     mov     ds, ax
    51 0000046D 8EC0                <1>     mov     es, ax
    52 0000046F 8EE0                <1>     mov     fs, ax
    53 00000471 8EE8                <1>     mov     gs, ax
    54 00000473 8ED0                <1>     mov     ss, ax
    55                              <1> 
    56                              <1>     OneTimeCallRet TransitionFromReal16To32BitFlat
    19 00000475 EB58                <2>  jmp %1 %+ OneTimerCallReturn
    57                              <1> 
    58 00000477 90                  <1> ALIGN   2
    59                              <1> 
    60                              <1> gdtr:
    61 00000478 3F00                <1>     dw      GDT_END - GDT_BASE - 1   ; GDT limit
    62 0000047A 10FFFFFF            <1>     dd      ADDR_OF(GDT_BASE)
    63                              <1> 
    64 0000047E 90<rep 2h>          <1> ALIGN   16
    65                              <1> 
    66                              <1> ;
    67                              <1> ; Macros for GDT entries
    68                              <1> ;
    69                              <1> 
    70                              <1> %define  PRESENT_FLAG(p) (p << 7)
    71                              <1> %define  DPL(dpl) (dpl << 5)
    72                              <1> %define  SYSTEM_FLAG(s) (s << 4)
    73                              <1> %define  DESC_TYPE(t) (t)
    74                              <1> 
    75                              <1> ; Type: data, expand-up, writable, accessed
    76                              <1> %define  DATA32_TYPE 3
    77                              <1> 
    78                              <1> ; Type: execute, readable, expand-up, accessed
    79                              <1> %define  CODE32_TYPE 0xb
    80                              <1> 
    81                              <1> ; Type: execute, readable, expand-up, accessed
    82                              <1> %define  CODE64_TYPE 0xb
    83                              <1> 
    84                              <1> %define  GRANULARITY_FLAG(g) (g << 7)
    85                              <1> %define  DEFAULT_SIZE32(d) (d << 6)
    86                              <1> %define  CODE64_FLAG(l) (l << 5)
    87                              <1> %define  UPPER_LIMIT(l) (l)
    88                              <1> 
    89                              <1> ;
    90                              <1> ; The Global Descriptor Table (GDT)
    91                              <1> ;
    92                              <1> 
    93                              <1> GDT_BASE:
    94                              <1> ; null descriptor
    95                              <1> NULL_SEL            equ $-GDT_BASE    ; Selector [0x0]
    96 00000480 0000                <1>     DW      0            ; limit 15:0
    97 00000482 0000                <1>     DW      0            ; base 15:0
    98 00000484 00                  <1>     DB      0            ; base 23:16
    99 00000485 00                  <1>     DB      0            ; sys flag, dpl, type
   100 00000486 00                  <1>     DB      0            ; limit 19:16, flags
   101 00000487 00                  <1>     DB      0            ; base 31:24
   102                              <1> 
   103                              <1> ; Spare segment descriptor
   104                              <1> SPARE1_SEL          equ $-GDT_BASE    ; Selector [0x8]
   105 00000488 0000                <1>     DW      0            ; limit 15:0
   106 0000048A 0000                <1>     DW      0            ; base 15:0
   107 0000048C 00                  <1>     DB      0            ; base 23:16
   108 0000048D 00                  <1>     DB      0            ; sys flag, dpl, type
   109 0000048E 00                  <1>     DB      0            ; limit 19:16, flags
   110 0000048F 00                  <1>     DB      0            ; base 31:24
   111                              <1> 
   112                              <1> ; linear code segment descriptor
   113                              <1> LINEAR_CODE_SEL     equ $-GDT_BASE    ; Selector [0x10]
   114 00000490 FFFF                <1>     DW      0xffff       ; limit 15:0
   115 00000492 0000                <1>     DW      0            ; base 15:0
   116 00000494 00                  <1>     DB      0            ; base 23:16
   117 00000495 9B                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(CODE32_TYPE)           ; 09Bh
   118 00000496 CF                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(1)|CODE64_FLAG(0)|UPPER_LIMIT(0xf)  ; 0CFh
   119 00000497 00                  <1>     DB      0            ; base 31:24
   120                              <1> 
   121                              <1> ; linear data segment descriptor
   122                              <1> LINEAR_SEL          equ $-GDT_BASE    ; Selector [0x18]
   123 00000498 FFFF                <1>     DW      0xffff       ; limit 15:0
   124 0000049A 0000                <1>     DW      0            ; base 15:0
   125 0000049C 00                  <1>     DB      0            ; base 23:16
   126 0000049D 93                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(DATA32_TYPE)           ; 093h
   127 0000049E CF                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(1)|CODE64_FLAG(0)|UPPER_LIMIT(0xf)  ; 0CFh
   128 0000049F 00                  <1>     DB      0            ; base 31:24
   129                              <1> 
   130                              <1> ; Spare segment descriptor
   131                              <1> SPARE2_SEL          equ $-GDT_BASE    ; Selector [0x20]
   132 000004A0 0000                <1>     DW      0            ; limit 15:0
   133 000004A2 0000                <1>     DW      0            ; base 15:0
   134 000004A4 00                  <1>     DB      0            ; base 23:16
   135 000004A5 00                  <1>     DB      0            ; sys flag, dpl, type
   136 000004A6 00                  <1>     DB      0            ; limit 19:16, flags
   137 000004A7 00                  <1>     DB      0            ; base 31:24
   138                              <1> 
   139                              <1> ; linear code (16-bit) segment descriptor
   140                              <1> LINEAR_CODE16_SEL   equ $-GDT_BASE    ; Selector [0x28]
   141 000004A8 FFFF                <1>     DW      0xffff       ; limit 15:0
   142 000004AA 0000                <1>     DW      0            ; base 15:0
   143 000004AC 00                  <1>     DB      0            ; base 23:16
   144 000004AD 9B                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(CODE32_TYPE)           ; 09Bh
   145 000004AE 8F                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(0)|CODE64_FLAG(0)|UPPER_LIMIT(0xf)  ; 08Fh
   146 000004AF 00                  <1>     DB      0            ; base 31:24
   147                              <1> 
   148                              <1> ; linear data (16-bit) segment descriptor
   149                              <1> LINEAR_DATA16_SEL   equ $-GDT_BASE    ; Selector [0x30]
   150 000004B0 FFFF                <1>     DW      0xffff       ; limit 15:0
   151 000004B2 0000                <1>     DW      0            ; base 15:0
   152 000004B4 00                  <1>     DB      0            ; base 23:16
   153 000004B5 93                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(DATA32_TYPE)           ; 093h
   154 000004B6 00                  <1>     DB      0
   155 000004B7 00                  <1>     DB      0            ; base 31:24
   156                              <1> 
   157                              <1> ; linear code (64-bit) segment descriptor
   158                              <1> LINEAR_CODE64_SEL   equ $-GDT_BASE    ; Selector [0x38]
   159 000004B8 FFFF                <1>     DW      0xffff       ; limit 15:0
   160 000004BA 0000                <1>     DW      0            ; base 15:0
   161 000004BC 00                  <1>     DB      0            ; base 23:16
   162 000004BD 9B                  <1>     DB      PRESENT_FLAG(1)|DPL(0)|SYSTEM_FLAG(1)|DESC_TYPE(CODE64_TYPE)           ; 09Bh
   163 000004BE AF                  <1>     DB      GRANULARITY_FLAG(1)|DEFAULT_SIZE32(0)|CODE64_FLAG(1)|UPPER_LIMIT(0xf)  ; 0AFh
   164 000004BF 00                  <1>     DB      0            ; base 31:24
   165                              <1> 
   166                              <1> GDT_END:
   167                              <1> 
   152                                  %include "Ia16/Init16.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; 16-bit initialization code
     4                              <1> ;
     5                              <1> ; Copyright (c) 2008 - 2009, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> 
    11                              <1> BITS    16
    12                              <1> 
    13                              <1> ;
    14                              <1> ; @param[out] DI    'BP' to indicate boot-strap processor
    15                              <1> ;
    16                              <1> EarlyBspInitReal16:
    17 000004C0 BF4250              <1>     mov     di, 'BP'
    18 000004C3 EB05                <1>     jmp     short Main16
    19                              <1> 
    20                              <1> ;
    21                              <1> ; Modified:  EAX
    22                              <1> ;
    23                              <1> ; @param[in]  EAX   Initial value of the EAX register (BIST: Built-in Self Test)
    24                              <1> ; @param[out] ESP   Initial value of the EAX register (BIST: Built-in Self Test)
    25                              <1> ;
    26                              <1> EarlyInit16:
    27                              <1>     ;
    28                              <1>     ; ESP -  Initial value of the EAX register (BIST: Built-in Self Test)
    29                              <1>     ;
    30 000004C5 6689C4              <1>     mov     esp, eax
    31                              <1> 
    32                              <1>     debugInitialize
    13                              <2> 
    14                              <2> 
    15                              <2> 
    33                              <1> 
    34                              <1>     OneTimeCallRet EarlyInit16
    19 000004C8 EB02                <2>  jmp %1 %+ OneTimerCallReturn
    35                              <1> 
   153                                  
   154                                  %include "Main.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; Main routine of the pre-SEC code up through the jump into SEC
     4                              <1> ;
     5                              <1> ; Copyright (c) 2008 - 2009, Intel Corporation. All rights reserved.<BR>
     6                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     7                              <1> ;
     8                              <1> ;------------------------------------------------------------------------------
     9                              <1> 
    10                              <1> 
    11                              <1> BITS    16
    12                              <1> 
    13                              <1> ;
    14                              <1> ; Modified:  EBX, ECX, EDX, EBP
    15                              <1> ;
    16                              <1> ; @param[in,out]  RAX/EAX  Initial value of the EAX register
    17                              <1> ;                          (BIST: Built-in Self Test)
    18                              <1> ; @param[in,out]  DI       'BP': boot-strap processor, or
    19                              <1> ;                          'AP': application processor
    20                              <1> ; @param[out]     RBP/EBP  Address of Boot Firmware Volume (BFV)
    21                              <1> ; @param[out]     DS       Selector allowing flat access to all addresses
    22                              <1> ; @param[out]     ES       Selector allowing flat access to all addresses
    23                              <1> ; @param[out]     FS       Selector allowing flat access to all addresses
    24                              <1> ; @param[out]     GS       Selector allowing flat access to all addresses
    25                              <1> ; @param[out]     SS       Selector allowing flat access to all addresses
    26                              <1> ;
    27                              <1> ; @return         None  This routine jumps to SEC and does not return
    28                              <1> ;
    29                              <1> Main16:
    30                              <1>     OneTimeCall EarlyInit16
    14 000004CA EBF9                <2>  jmp %1
    15                              <2> %1 %+ OneTimerCallReturn:
    31                              <1> 
    32                              <1>     ;
    33                              <1>     ; Transition the processor from 16-bit real mode to 32-bit flat mode
    34                              <1>     ;
    35                              <1>     OneTimeCall TransitionFromReal16To32BitFlat
    14 000004CC E971FF              <2>  jmp %1
    15                              <2> %1 %+ OneTimerCallReturn:
    36                              <1> 
    37                              <1> BITS    32
    38                              <1> 
    39                              <1>     ; Clear the WorkArea header. The SEV probe routines will populate the
    40                              <1>     ; work area when detected.
    41 000004CF C6050080800000      <1>     mov     byte[WORK_AREA_GUEST_TYPE], 0
    42                              <1> 
    43                              <1> %ifdef ARCH_X64
    44                              <1> 
    45                              <1>     jmp SearchBfv
    46                              <1> 
    47                              <1> ;
    48                              <1> ; Entry point of Main32
    49                              <1> ;
    50                              <1> Main32:
    51                              <1>     OneTimeCall InitTdx
    52                              <1> 
    53                              <1> SearchBfv:
    54                              <1> 
    55                              <1> %endif
    56                              <1> 
    57                              <1>     ;
    58                              <1>     ; Search for the Boot Firmware Volume (BFV)
    59                              <1>     ;
    60                              <1>     OneTimeCall Flat32SearchForBfvBase
    14 000004D6 E925FBFFFF          <2>  jmp %1
    15                              <2> %1 %+ OneTimerCallReturn:
    61                              <1> 
    62                              <1>     ;
    63                              <1>     ; EBP - Start of BFV
    64                              <1>     ;
    65                              <1> 
    66                              <1>     ;
    67                              <1>     ; Search for the SEC entry point
    68                              <1>     ;
    69                              <1>     OneTimeCall Flat32SearchForSecEntryPoint
    14 000004DB E997FBFFFF          <2>  jmp %1
    15                              <2> %1 %+ OneTimerCallReturn:
    70                              <1> 
    71                              <1>     ;
    72                              <1>     ; ESI - SEC Core entry point
    73                              <1>     ; EBP - Start of BFV
    74                              <1>     ;
    75                              <1> 
    76                              <1> %ifdef ARCH_IA32
    77                              <1> 
    78                              <1>     ;
    79                              <1>     ; SEV support can be built and run using the Ia32/X64 split environment.
    80                              <1>     ; Set the OVMF/SEV work area as appropriate.
    81                              <1>     ;
    82                              <1>     OneTimeCall CheckSevFeatures
    14 000004E0 E974FCFFFF          <2>  jmp %1
    15                              <2> %1 %+ OneTimerCallReturn:
    83                              <1> 
    84                              <1>     ;
    85                              <1>     ; Restore initial EAX value into the EAX register
    86                              <1>     ;
    87 000004E5 89E0                <1>     mov     eax, esp
    88                              <1> 
    89                              <1>     ;
    90                              <1>     ; Jump to the 32-bit SEC entry point
    91                              <1>     ;
    92 000004E7 FFE6                <1>     jmp     esi
    93                              <1> 
    94                              <1> %else
    95                              <1> 
    96                              <1>     ;
    97                              <1>     ; Transition the processor from 32-bit flat mode to 64-bit flat mode
    98                              <1>     ;
    99                              <1>     OneTimeCall Transition32FlatTo64Flat
   100                              <1> 
   101                              <1> BITS    64
   102                              <1> 
   103                              <1>     ;
   104                              <1>     ; Some values were calculated in 32-bit mode.  Make sure the upper
   105                              <1>     ; 32-bits of 64-bit registers are zero for these values.
   106                              <1>     ;
   107                              <1>     mov     rax, 0x00000000ffffffff
   108                              <1>     and     rsi, rax
   109                              <1>     and     rbp, rax
   110                              <1>     and     rsp, rax
   111                              <1> 
   112                              <1>     ;
   113                              <1>     ; RSI - SEC Core entry point
   114                              <1>     ; RBP - Start of BFV
   115                              <1>     ;
   116                              <1> 
   117                              <1>     ;
   118                              <1>     ; Restore initial EAX value into the RAX register
   119                              <1>     ;
   120                              <1>     mov     rax, rsp
   121                              <1> 
   122                              <1>     ;
   123                              <1>     ; Jump to the 64-bit SEC entry point
   124                              <1>     ;
   125                              <1>     jmp     rsi
   126                              <1> 
   127                              <1> %endif
   155                                  
   156                                    %define SEV_ES_AP_RESET_IP 8421380
   157                                    %define SEV_LAUNCH_SECRET_BASE 00h
   158                                    %define SEV_LAUNCH_SECRET_SIZE 00h
   159                                    %define SEV_FW_HASH_BLOCK_BASE 00h
   160                                    %define SEV_FW_HASH_BLOCK_SIZE 00h
   161                                  %include "Ia16/ResetVectorVtf0.asm"
     1                              <1> ;------------------------------------------------------------------------------
     2                              <1> ; @file
     3                              <1> ; First code executed by processor after resetting.
     4                              <1> ; Derived from UefiCpuPkg/ResetVector/Vtf0/Ia16/ResetVectorVtf0.asm
     5                              <1> ;
     6                              <1> ; Copyright (c) 2008 - 2014, Intel Corporation. All rights reserved.<BR>
     7                              <1> ; SPDX-License-Identifier: BSD-2-Clause-Patent
     8                              <1> ;
     9                              <1> ;------------------------------------------------------------------------------
    10                              <1> 
    11                              <1> BITS    16
    12                              <1> 
    13 000004E9 90<rep 7h>          <1> ALIGN   16
    14                              <1> 
    15                              <1> ;
    16                              <1> ; Pad the image size to 4k when page tables are in VTF0
    17                              <1> ;
    18                              <1> ; If the VTF0 image has page tables built in, then we need to make
    19                              <1> ; sure the end of VTF0 is 4k above where the page tables end.
    20                              <1> ;
    21                              <1> ; This is required so the page tables will be 4k aligned when VTF0 is
    22                              <1> ; located just below 0x100000000 (4GB) in the firmware device.
    23                              <1> ;
    24                              <1> %ifdef ALIGN_TOP_TO_4K_FOR_PAGING
    25                              <1>     TIMES (0x1000 - ($ - EndOfPageTables) - 0x20) DB 0
    26                              <1> %endif
    27                              <1> 
    28                              <1> ;
    29                              <1> ; Padding to ensure first guid starts at 0xffffffd0
    30                              <1> ;
    31 000004F0 00<rep 4h>          <1> TIMES (15 - ((guidedStructureEnd - guidedStructureStart + 15) % 16)) DB 0
    32                              <1> 
    33                              <1> ; GUIDed structure.  To traverse this you should first verify the
    34                              <1> ; presence of the table footer guid
    35                              <1> ; (96b582de-1fb2-45f7-baea-a366c55a082d) at 0xffffffd0.  If that
    36                              <1> ; is found, the two bytes at 0xffffffce are the entire table length.
    37                              <1> ;
    38                              <1> ; The table is composed of structures with the form:
    39                              <1> ;
    40                              <1> ; Data (arbitrary bytes identified by guid)
    41                              <1> ; length from start of data to end of guid (2 bytes)
    42                              <1> ; guid (16 bytes)
    43                              <1> ;
    44                              <1> ; so work back from the footer using the length to traverse until you
    45                              <1> ; either find the guid you're looking for or run off the beginning of
    46                              <1> ; the table.
    47                              <1> ;
    48                              <1> guidedStructureStart:
    49                              <1> 
    50                              <1> %ifdef ARCH_X64
    51                              <1> ;
    52                              <1> ; TDX Metadata offset block
    53                              <1> ;
    54                              <1> ; TdxMetadata.asm is included in ARCH_X64 because Inte TDX is only
    55                              <1> ; available in ARCH_X64. Below block describes the offset of
    56                              <1> ; TdxMetadata block in Ovmf image
    57                              <1> ;
    58                              <1> ; GUID : e47a6535-984a-4798-865e-4685a7bf8ec2
    59                              <1> ;
    60                              <1> tdxMetadataOffsetStart:
    61                              <1>     DD      fourGigabytes - TdxMetadataGuid - 16
    62                              <1>     DW      tdxMetadataOffsetEnd - tdxMetadataOffsetStart
    63                              <1>     DB      0x35, 0x65, 0x7a, 0xe4, 0x4a, 0x98, 0x98, 0x47
    64                              <1>     DB      0x86, 0x5e, 0x46, 0x85, 0xa7, 0xbf, 0x8e, 0xc2
    65                              <1> tdxMetadataOffsetEnd:
    66                              <1> 
    67                              <1> ;
    68                              <1> ; SEV metadata descriptor
    69                              <1> ;
    70                              <1> ; Provide the start offset of the metadata blob within the OVMF binary.
    71                              <1> 
    72                              <1> ; GUID : dc886566-984a-4798-A75e-5585a7bf67cc
    73                              <1> ;
    74                              <1> OvmfSevMetadataOffsetStart:
    75                              <1>   DD      (fourGigabytes - OvmfSevMetadataGuid)
    76                              <1>   DW      OvmfSevMetadataOffsetEnd - OvmfSevMetadataOffsetStart
    77                              <1>   DB      0x66, 0x65, 0x88, 0xdc, 0x4a, 0x98, 0x98, 0x47
    78                              <1>   DB      0xA7, 0x5e, 0x55, 0x85, 0xa7, 0xbf, 0x67, 0xcc
    79                              <1> OvmfSevMetadataOffsetEnd:
    80                              <1> 
    81                              <1> %endif
    82                              <1> 
    83                              <1> ; SEV Hash Table Block
    84                              <1> ;
    85                              <1> ; This describes the guest ram area where the hypervisor should
    86                              <1> ; install a table describing the hashes of certain firmware configuration
    87                              <1> ; device files that would otherwise be passed in unchecked.  The current
    88                              <1> ; use is for the kernel, initrd and command line values, but others may be
    89                              <1> ; added.  The data format is:
    90                              <1> ;
    91                              <1> ; base physical address (32 bit word)
    92                              <1> ; table length (32 bit word)
    93                              <1> ;
    94                              <1> ; GUID (SEV FW config hash block): 7255371f-3a3b-4b04-927b-1da6efa8d454
    95                              <1> ;
    96                              <1> sevFwHashBlockStart:
    97 000004F4 00000000            <1>     DD      SEV_FW_HASH_BLOCK_BASE
    98 000004F8 00000000            <1>     DD      SEV_FW_HASH_BLOCK_SIZE
    99 000004FC 1A00                <1>     DW      sevFwHashBlockEnd - sevFwHashBlockStart
   100 000004FE 1F3755723B3A044B    <1>     DB      0x1f, 0x37, 0x55, 0x72, 0x3b, 0x3a, 0x04, 0x4b
   101 00000506 927B1DA6EFA8D454    <1>     DB      0x92, 0x7b, 0x1d, 0xa6, 0xef, 0xa8, 0xd4, 0x54
   102                              <1> sevFwHashBlockEnd:
   103                              <1> 
   104                              <1> ; SEV Secret block
   105                              <1> ;
   106                              <1> ; This describes the guest ram area where the hypervisor should
   107                              <1> ; inject the secret.  The data format is:
   108                              <1> ;
   109                              <1> ; base physical address (32 bit word)
   110                              <1> ; table length (32 bit word)
   111                              <1> ;
   112                              <1> ; GUID (SEV secret block): 4c2eb361-7d9b-4cc3-8081-127c90d3d294
   113                              <1> ;
   114                              <1> sevSecretBlockStart:
   115 0000050E 00000000            <1>     DD      SEV_LAUNCH_SECRET_BASE
   116 00000512 00000000            <1>     DD      SEV_LAUNCH_SECRET_SIZE
   117 00000516 1A00                <1>     DW      sevSecretBlockEnd - sevSecretBlockStart
   118 00000518 61B32E4C9B7DC34C    <1>     DB      0x61, 0xB3, 0x2E, 0x4C, 0x9B, 0x7D, 0xC3, 0x4C
   119 00000520 8081127C90D3D294    <1>     DB      0x80, 0x81, 0x12, 0x7C, 0x90, 0xD3, 0xD2, 0x94
   120                              <1> sevSecretBlockEnd:
   121                              <1> 
   122                              <1> ;
   123                              <1> ; SEV-ES Processor Reset support
   124                              <1> ;
   125                              <1> ; sevEsResetBlock:
   126                              <1> ;   For the initial boot of an AP under SEV-ES, the "reset" RIP must be
   127                              <1> ;   programmed to the RAM area defined by SEV_ES_AP_RESET_IP. The data
   128                              <1> ;   format is:
   129                              <1> ;
   130                              <1> ;   IP value [0:15]
   131                              <1> ;   CS segment base [31:16]
   132                              <1> ;
   133                              <1> ;   GUID (SEV-ES reset block): 00f771de-1a7e-4fcb-890e-68c77e2fb44e
   134                              <1> ;
   135                              <1> ;   A hypervisor reads the CS segement base and IP value. The CS segment base
   136                              <1> ;   value represents the high order 16-bits of the CS segment base, so the
   137                              <1> ;   hypervisor must left shift the value of the CS segement base by 16 bits to
   138                              <1> ;   form the full CS segment base for the CS segment register. It would then
   139                              <1> ;   program the EIP register with the IP value as read.
   140                              <1> ;
   141                              <1> 
   142                              <1> sevEsResetBlockStart:
   143 00000528 04808000            <1>     DD      SEV_ES_AP_RESET_IP
   144 0000052C 1600                <1>     DW      sevEsResetBlockEnd - sevEsResetBlockStart
   145 0000052E DE71F7007E1ACB4F    <1>     DB      0xDE, 0x71, 0xF7, 0x00, 0x7E, 0x1A, 0xCB, 0x4F
   146 00000536 890E68C77E2FB44E    <1>     DB      0x89, 0x0E, 0x68, 0xC7, 0x7E, 0x2F, 0xB4, 0x4E
   147                              <1> sevEsResetBlockEnd:
   148                              <1> 
   149                              <1> ;
   150                              <1> ; Table footer:
   151                              <1> ;
   152                              <1> ; length of whole table (16 bit word)
   153                              <1> ; GUID (table footer): 96b582de-1fb2-45f7-baea-a366c55a082d
   154                              <1> ;
   155 0000053E 5C00                <1>     DW      guidedStructureEnd - guidedStructureStart
   156 00000540 DE82B596B21FF745    <1>     DB      0xDE, 0x82, 0xB5, 0x96, 0xB2, 0x1F, 0xF7, 0x45
   157 00000548 BAEAA366C55A082D    <1>     DB      0xBA, 0xEA, 0xA3, 0x66, 0xC5, 0x5A, 0x08, 0x2D
   158                              <1> 
   159                              <1> guidedStructureEnd:
   160                              <1> 
   161                              <1> ALIGN   16
   162                              <1> 
   163                              <1> ;
   164                              <1> ; 0xffffffe0
   165                              <1> ;
   166 00000550 000000000000000000- <1>     DD      0, 0, 0
   166 00000559 000000              <1>
   167                              <1> 
   168                              <1> ;
   169                              <1> ; The VTF signature (0xffffffec)
   170                              <1> ;
   171                              <1> ; VTF-0 means that the VTF (Volume Top File) code does not require
   172                              <1> ; any fixups.
   173                              <1> ;
   174                              <1> vtfSignature:
   175 0000055C 56544600            <1>     DB      'V', 'T', 'F', 0
   176                              <1> 
   177                              <1> ALIGN   16
   178                              <1> 
   179                              <1> resetVector:
   180                              <1> ;
   181                              <1> ; Reset Vector
   182                              <1> ;
   183                              <1> ; This is where the processor will begin execution
   184                              <1> ;
   185                              <1> ; In IA32 we follow the standard reset vector flow. While in X64, Td guest
   186                              <1> ; may be supported. Td guest requires the startup mode to be 32-bit
   187                              <1> ; protected mode but the legacy VM startup mode is 16-bit real mode.
   188                              <1> ; To make NASM generate such shared entry code that behaves correctly in
   189                              <1> ; both 16-bit and 32-bit mode, more BITS directives are added.
   190                              <1> ;
   191                              <1> %ifdef ARCH_IA32
   192 00000560 90                  <1>     nop
   193 00000561 90                  <1>     nop
   194 00000562 E95BFF              <1>     jmp     EarlyBspInitReal16
   195                              <1> 
   196                              <1> %else
   197                              <1> 
   198                              <1>     mov     eax, cr0
   199                              <1>     test    al, 1
   200                              <1>     jz      .Real
   201                              <1> BITS 32
   202                              <1>     jmp     Main32
   203                              <1> BITS 16
   204                              <1> .Real:
   205                              <1>     jmp     EarlyBspInitReal16
   206                              <1> 
   207                              <1> %endif
   208                              <1> 
   209 00000565 90<rep Bh>          <1> ALIGN   16
   210                              <1> 
   211                              <1> fourGigabytes:
   212                              <1> 
